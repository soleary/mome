#!/usr/bin/env perl

use warnings;
use strict;

use Modern::Perl '2018';
use DBI;
use DateTime;
use Data::Dumper;
use Text::CSV;

use lib 'lib';

use MOME;

my $csv = Text::CSV->new();

# Number of days one has to make a payment
my $DBFILE = 'sjsmusic.db';
my $dbh = DBI->connect("dbi:SQLite:dbname=$DBFILE",'','', { RaiseError => 1 });

my $service = MOME::google_sheets();

# ws is the worksheet name
# sent is a flag to track which sheets have notifications on them
my %sheets = (
    'paid-up' => {
        ws    => $service->spreadsheet({title => 'paid-ups'}),
        sent  => 0,
    },
    'payment' => {
        ws    => $service->spreadsheet({title => 'payments'}),
        sent  => 0,
    },
);

sub format_day {
    my $num = shift;

    my $suffix = '';
    for ($num) {
        if (/^11$/) { $suffix = 'th'; last; }
        if (/^12$/) { $suffix = 'th'; last; }
        if (/^13$/) { $suffix = 'th'; last; }
        if (/1$/)   { $suffix = 'st'; last; }
        if (/2$/)   { $suffix = 'nd'; last; }
        if (/3$/)   { $suffix = 'rd'; last; }
        default { $suffix = 'th' }
    }

    return $num . $suffix;
}

sub ce {
    return '' unless defined $_[0];
    return $_[0];
}

sub get_notification {
    my $id = $_[0];

    return $dbh->selectrow_hashref(
        qq{ select momefid, type, date from notification where id = ?; },
        undef,
        $id,
    );
}

sub get_parents {
    my $id = $_[0];

    my $parent_st = qq{ select firstname, lastname, email, id as personid from person where
                type = 'parent' and
                email is not null and
                id in (select personid from family_member where momefid = ?)};

    my $parent_sth = $dbh->prepare_cached($parent_st);
    $parent_sth->execute($id);

    my @fields = qw/ first last email /;
    my @parents = ();

    my $row;
    while ( $row = $parent_sth->fetchrow_hashref() ) {
        push @parents, $row;
    }
    $parent_sth->finish();

    return @parents;
}

sub format_date {
    my $d = shift;

    my @date_parts = split /-/, $d;
    my @fields = qw/ year month day /;

    my %date;
    my $x;
    foreach my $f (@fields) {
        $date{$f} = $date_parts[$x++];
    }

    my $dt = DateTime->new( %date );
    return sprintf '%s, %s %s, %s', $dt->day_name(), $dt->month_name(), format_day($dt->day()), $dt->year();
}

my @email_fields = ('First Name', 'Last Name', 'Email Address', 'File Attachments', 'Scheduled Date', 'Mail Merge Status');
my @out_fields = (@email_fields, qw/ date /);

#foreach my $s (values %sheets) {
#    $s->{ws} = $s->{ws}->worksheet({title => 'Mail Merge'});
#    my @cells = $s->{ws}->cells({ 'max-row' => 1, 'return-end' => 1 });
#    my @headers = map { $_->content() } @cells;
#    my $headers_match = 1;
#
#    if (@headers == 0 or @headers != @out_fields) {
#        $headers_match = 0;
#    } else {
#        $headers_match = 1;
#        foreach my $i (0..$#headers) {
#            if ($headers[$i] ne $out_fields[$i]) {
#                $headers_match = 0;
#                last;
#            }
#        }
#    }
#
#    # Die if the headers don't match, but not if the sheet's blank
#    die "Output fields do not match! Delete data and run again.\n" unless $headers_match or @headers == 0;
#
#    unless (@headers) {
#        my $x = 1;
#        my $y = 1;
#        my @title_row = map { { row => $y, col => $x++, input_value => $_ } } @out_fields;
#        $s->{ws}->batchupdate_cell( @title_row );
#    }
#
#    # $y needs to start out as the index of the fist blank row, so we add one
#    # Perl arrays are zero-indexed, Google sheet rows are one-indexed, so we add another one
#    my @rows = $s->{ws}->rows();
#    $s->{y} = @rows + 1 + 1;
#}

foreach my $s (keys %sheets) {
    open my $fh, '>', "$s.csv" or die "Can't open $s.csv: $!\n";
    $sheets{$s}->{file} = $fh;
    $csv->say($fh, \@out_fields);
}

my %emails_seen = ();

sub notification_to_google {
    my $n = shift; # Notification hash
    my $s = shift; # Sheet hash

    $n->{date} = format_date $n->{date};

    my $sent = $s->{$n->{type}}->{sent};

    #XXX: debug
    use Data::Dumper;
    print Dumper $sent;
    print Dumper $s->{$n->{type}};

    unless ($sent) {
        printf "There are %s notifications to send.\n", $n->{type};
        $sent++;
    }

    my @parents = get_parents $n->{momefid};

    foreach my $parent (@parents) {
        if ($emails_seen{$parent->{email}}++) {
            next;
        }

        my @row = ();
        my @more_fields = qw/ date /;

        # Parent info for invoice
        foreach my $f (qw/ firstname lastname email /){
            push @row, $parent->{$f};
        }

        # Blank columns to appease the mail merge app
        foreach my $n (1..3) {
            push @row, undef;
        }

        # Additional fields for invoice template
        foreach my $f (@more_fields) {
            push @row, $n->{$f};
        }

        #my $x = 1;
        #my @sheet_row = map { { row => $s->{y}, col => $x++, input_value => ce($_) } } @row;
        #$s->{ws}->batchupdate_cell( @sheet_row );

        #$s->{y}++;
        $csv->say($s->{file}, \@row);
    }
}

my @ids = $dbh->selectall_array(
    qq{ select id from notification where superseded is null and sentdate is null; }
);

foreach my $id (@ids) {
    my $n = get_notification($id->[0]);
    notification_to_google($n, $sheets{$n->{type}});
}

system './send-notifications';
