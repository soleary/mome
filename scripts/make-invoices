#!/usr/bin/env perl

use warnings;
use strict;

use Modern::Perl '2018';
use DBI;
use Getopt::Long;
use DateTime;

use lib 'lib';

use MOME;

my $TESTING;
# Number of days after payment date that a payment is due.
my $PAYMENT_INTERVAL = 5;
# Balance amount under wich we don't send an invoice - they are still recorded in DB
my $INVOICE_THRESHOLD = 5;
my $PAYPAL_BASE = 'https://www.paypal.me/mrsolearymusic/';
my $DBFILE = 'sjsmusic.db';
my $dbh = DBI->connect("dbi:SQLite:dbname=$DBFILE",'','', { RaiseError => 1 });

my $tz = DateTime::TimeZone->new( name => 'local' );

my $service = MOME::google_sheets();

my $F;
my $E;
GetOptions(
    'force|followup' => \$F,
    'early'          => \$E,
);

unless ($F or $E or today_is_payment_date()) {
    die "Today isn't a payment date and --force, --followup or --early not specified.\n";
}

my $title = $F ? 'past-dues' : 'invoices';

my $spreadsheet = $service->spreadsheet({title => $title});
my $invoice_sheet = $spreadsheet->worksheet({title => 'Mail Merge'});

sub paypal_amount {
    my $cash = $_[0];

    $cash += .30;
    return sprintf "%.2f", $cash / ( 1 - .029 );
}

sub paypal_url {
    my $amount = $_[0];

    return "$PAYPAL_BASE$amount";
}

sub get_parents {
    my $id = $_[0];

    my $parent_st = qq{ select firstname, lastname, email, id as personid from person where
                type = 'parent' and
                email is not null and
                id in (select personid from family_member where momefid = ?)};

    my $parent_sth = $dbh->prepare_cached($parent_st);
    $parent_sth->execute($id);

    my @fields = qw/ first last email /;
    my @parents = ();

    my $row;
    while ( $row = $parent_sth->fetchrow_hashref() ) {
        push @parents, $row;
    }
    $parent_sth->finish();

    return @parents;
}

sub invoice_date {
    my $id = DateTime->now();

    $id->set_time_zone($tz);

    return $id, sprintf '%s, %s %s, %s', $id->day_name(), $id->month_name(), format_day($id->day()), $id->year();
}

sub payment_date {
    my $id; # Invoice Date
    my $pd; # Payment Date

    if ($E) {
        my ($next_billing_date) = $dbh->selectall_array(
            qq{ select date from payment_schedule where date > date('now', 'localtime') order by date limit 1; }
        );
        my ($y, $m, $d) = split '-', $next_billing_date->[0];
        $id = DateTime->new(year => $y, month => $m, day => $d);
    } else {
        $id = DateTime->now();
    }

    if ($F) {
        $pd = $id;
    } else {
        $pd = $id->add(days => $PAYMENT_INTERVAL);
    }

    $pd->set_time_zone($tz);

    return $pd, sprintf '%s, %s %s, %s', $pd->day_name(), $pd->month_name(), format_day($pd->day()), $pd->year();
}

sub today_is_payment_date {
    return @{$dbh->selectrow_arrayref(qq{ select count(*) from payment_schedule where date = date('now', 'localtime'); })}[0];
}

sub format_day {
    my $num = shift;

    my $suffix = '';
    for ($num) {
        if (/^11$/) { $suffix = 'th'; last; }
        if (/^12$/) { $suffix = 'th'; last; }
        if (/^13$/) { $suffix = 'th'; last; }
        if (/1$/)   { $suffix = 'st'; last; }
        if (/2$/)   { $suffix = 'nd'; last; }
        if (/3$/)   { $suffix = 'rd'; last; }
        default { $suffix .= 'th' }
    }

    return $num . $suffix;
}

sub payment_word {
    return "payment" if $_[0] == 1;
    return "payments";
}

sub record_to_db {
    my %i = @_;

    my $inv_sth = $dbh->prepare_cached(qq{
        insert into invoice
            (personid, amount, paypal, date, duedate, donotsend, testing, session)
            values (?,?,?,?,?,?,?,(select id from session where active is not null));
    });

    $inv_sth->execute($i{personid}, $i{balance}, $i{paypal}, $i{invoice_dt}->ymd(), $i{payment_dt}->ymd(), $i{donotsend}, $TESTING);

    return $dbh->last_insert_id('','', 'invoice', 'id');
}

my @email_fields = ('First Name', 'Last Name', 'Email Address', 'File Attachments', 'Scheduled Date', 'Mail Merge Status');
my @inv_fields = qw/ momefid balance plan tuition payment_word paypal paypal_url invoice_date payment_date /;
my @out_fields = (@email_fields, 'invid',  @inv_fields);

my @cells = $invoice_sheet->cells({ 'max-row' => 1, 'return-end' => 1 });

my @headers = map { $_->content() } @cells;

my $headers_match = 1;

if (@headers == 0 or @headers != @out_fields) {
    $headers_match = 0;
} else {
    $headers_match = 1;
    foreach my $i (0..$#headers) {
        if ($headers[$i] ne $out_fields[$i]) {
            $headers_match = 0;
            last;
        }
    }
}

# Die if the headers don't match, but not if the sheet's blank
die "Output fields do not match! Delete data and run again.\n" unless $headers_match or @headers == 0;

unless (@headers) {
    my $x = 1;
    my $y = 1;
    my @title_row = map { { row => $y, col => $x++, input_value => $_ } } @out_fields;
    $invoice_sheet->batchupdate_cell( @title_row );

    warn "This looks like a new spreadsheet.  Make sure 'balance', 'tuition', and 'paypal' columns are formatted as 'Financial'";
}

my %emails_seen = ();

# $y needs to start out as the index of the fist blank row, so we add one
# Perl arrays are zero-indexed, Google sheet rows are one-indexed, so we add another one
my @existing_rows = $invoice_sheet->rows();
my $y = @existing_rows + 1 + 1;

sub invoice_to_google {
    my $act = $_[0];

    # Balances will be negative, since these are people that owe
    # But we don't want to show people that on their invoice
    $act->{balance} =~ s/^-//;
    $act->{balance} = sprintf '%.2f', $act->{balance};
    $act->{tuition} = sprintf '%.2f', $act->{tuition};
    $act->{paypal} = paypal_amount $act->{balance};
    $act->{paypal_url} = paypal_url $act->{paypal};
    $act->{payment_word} = payment_word $act->{plan};
    ($act->{invoice_dt}, $act->{invoice_date}) = invoice_date();
    ($act->{payment_dt}, $act->{payment_date}) = payment_date();

    if ($act->{nobill} eq 'I' or $act->{nobill} eq 'B' or $act->{balance} < $INVOICE_THRESHOLD) {
        $act->{donotsend} = 1;
    }

    my @parents = get_parents $act->{momefid};
    foreach my $parent (@parents) {
        if ($emails_seen{$parent->{email}}++) {
            next;
        }

        my $invid = record_to_db(%{$act}, %{$parent});

        if ($act->{donotsend}) {
            warn 'Not sending invoice for ' . $act->{momefid} . ' ' . $act->{short_name};
            next;
        }

        my @row = ();

        # Parent info for invoice
        foreach my $f (qw/ firstname lastname email /){
            push @row, $parent->{$f};
        }

        # Blank columns to appease the mail merge app
        foreach my $n (1..3) {
            push @row, undef;
        }

        push @row, $invid;

        # Additional fields for invoice template
        foreach my $f (@inv_fields) {
            push @row, $act->{$f};
        }

        # I would use ->add_row(\%), but for some damned reason it can't handle
        # spaces in the "Column Names", the keys of the hash.
        # Spaces must be present in the @email_fields to keep the Google Sheet Mail Merge
        # application happy.
        my $x = 1;
        my @sheet_row = map { { row => $y, col => $x++, input_value => ce($_) } } @row;
        $invoice_sheet->batchupdate_cell( @sheet_row );

        $y++;
    }
}

sub ce {
    return '' unless defined $_[0];
    return $_[0];
}

sub get_account {
    my $momefid = $_[0];

    my $act = $dbh->selectrow_hashref(
        qq{ select momefid, tuition, plan, name, nobill from family where momefid = ?; },
        undef,
        $momefid,
    );

    ($act->{short_name}) = split '/', $act->{name};

    return $act;
}

sub get_balance {
    my $momefid = $_[0];

    my $count = $dbh->selectrow_hashref(
        qq{ select count(id) as count from ledger where type = 'debit' and momefid = ? },
        undef,
        $momefid,
    );

    unless ($count->{count}) {
        return 0, 0;
    }

    my $balance = $dbh->selectrow_hashref(
        qq{ select sum(amount) as balance from ledger where momefid = ?; },
        undef,
        $momefid,
    );

    return $balance->{balance}, $count->{count};
}

my @ids_arr = $dbh->selectall_array(
    qq{ select momefid from family where session = (select id from session where active is not null); }
);

my @ids = map { $_->[0] } @ids_arr;

my $id_str = join ',', @ids;

my @count = $dbh->selectall_array(
    qq{ select count(id) from family where momefid in ($id_str) and nobill != ''; }
);

if ($count[0]->[0]) {
    warn "There is at least one account with non-standard billing status in this invoice queue. See `./billing-status` for details.";
}

foreach my $id (@ids) {
    my $act = get_account($id);

    ($act->{balance}, $act->{count}) = get_balance($id);

    if ($act->{balance} < 0) {
        invoice_to_google($act);
    }
}
