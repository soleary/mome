#!/usr/bin/env perl

use warnings;
use strict;

use Modern::Perl '2018';
use DBI;
use Getopt::Long;
use DateTime;

use lib 'lib';

use MOME;

my $TESTING;
# Number of days one has to make a payment
my $PAYMENT_INTERVAL = 5;
# Balance amount under wich we don't send an invoice - they are still recorded in DB
my $INV_THRESHOLD = 5;
my $PAYPAL_BASE = 'https://www.paypal.me/mrsolearymusic/';
my $DBFILE = 'sjsmusic.db';
my $dbh = DBI->connect("dbi:SQLite:dbname=$DBFILE",'','', { RaiseError => 1 });

my $tz = DateTime::TimeZone->new( name => 'local' );

my $service = MOME::google_sheets();

my $F;
GetOptions(
    'force|followup' => \$F,
);

my $date = today();

unless (today_is_payment_date() or $F) {
    die "Today isn't a payment date and --force or --followup not specified.\n";
}

my $title = $F ? 'past-dues' : 'invoices';

my $spreadsheet = $service->spreadsheet({title => $title});
my $invoice_sheet = $spreadsheet->worksheet({title => 'Mail Merge'});

sub paypal_amount {
    my $cash = $_[0];

    $cash += .30;
    return sprintf "%.2f", $cash / ( 1 - .029 );
}

sub paypal_url {
    my $amount = $_[0];

    return "$PAYPAL_BASE$amount";
}

sub get_parents {
    my $id = $_[0];

    my $parent_st = qq{ select firstname, lastname, email, id as personid from person where
                type = 'parent' and
                email is not null and
                id in (select personid from family_member where momefid = ?)};

    my $parent_sth = $dbh->prepare_cached($parent_st);
    $parent_sth->execute($id);

    my @fields = qw/ first last email /;
    my @parents = ();

    my $row;
    while ( $row = $parent_sth->fetchrow_hashref() ) {
        push @parents, $row;
    }
    $parent_sth->finish();

    return @parents;
}

sub today {
    my $dt = DateTime->now();
    $dt->set_time_zone($tz);
    return $dt, sprintf '%s, %s %s, %s', $dt->day_name(), $dt->month_name(), format_day($dt->day()), $dt->year();
}

sub payment_date {
    my $dt = DateTime->now();

    $dt->set_time_zone($tz);

    if (today_is_payment_date()) {
        $dt->add(days => $PAYMENT_INTERVAL);
    }

    return $dt, sprintf '%s, %s %s, %s', $dt->day_name(), $dt->month_name(), format_day($dt->day()), $dt->year();
}

sub today_is_payment_date {
    return @{$dbh->selectrow_arrayref(qq{ select count(*) from payment_schedule where date = date('now', 'localtime'); })}[0];
}

sub format_day {
    my $num = shift;

    my $suffix = '';
    for ($num) {
        if (/^11$/) { $suffix = 'th'; last; }
        if (/^12$/) { $suffix = 'th'; last; }
        if (/^13$/) { $suffix = 'th'; last; }
        if (/1$/)   { $suffix = 'st'; last; }
        if (/2$/)   { $suffix = 'nd'; last; }
        if (/3$/)   { $suffix = 'rd'; last; }
        default { $suffix .= 'th' }
    }

    return $num . $suffix;
}

sub this_month {
    return @{$dbh->selectrow_arrayref(qq{ select date('now', localtime'); })}[0] =~ s/-\d\{2\}$//;
}

sub payment_word {
    return "payment" if $_[0] == 1;
    return "payments";
}

sub record_to_db {
    my %i = @_;

    my $inv_sth = $dbh->prepare_cached(qq{
        insert into invoice
            (personid, amount, paypal, date, duedate, donotsend, testing, session)
            values (?,?,?,?,?,?,?,(select id from session where active is not null));
    });

    $inv_sth->execute($i{personid}, $i{balance}, $i{paypal}, $i{invoice_dt}->ymd(), $i{payment_dt}->ymd(), $i{donotsend}, $TESTING);

    return $dbh->last_insert_id('','', 'invoice', 'id');
}

my @email_fields = ('First Name', 'Last Name', 'Email Address', 'File Attachments', 'Scheduled Date', 'Mail Merge Status');
my @inv_fields = qw/ momefid balance plan tuition payment_word paypal paypal_url invoice_date payment_date /;
my @out_fields = (@email_fields, 'invid',  @inv_fields);

my @cells = $invoice_sheet->cells({ 'max-row' => 1, 'return-end' => 1 });

my @headers = map { $_->content() } @cells;

my $headers_match = 1;

if (@headers == 0 or @headers != @out_fields) {
    $headers_match = 0;
} else {
    $headers_match = 1;
    foreach my $i (0..$#headers) {
        if ($headers[$i] ne $out_fields[$i]) {
            $headers_match = 0;
            last;
        }
    }
}

# Die if the headers don't match, but not if the sheet's blank
die "Output fields do not match! Delete data and run again.\n" unless $headers_match or @headers == 0;

unless (@headers) {
    my $x = 1;
    my $y = 1;
    my @title_row = map { { row => $y, col => $x++, input_value => $_ } } @out_fields;
    $invoice_sheet->batchupdate_cell( @title_row );

    warn "This looks like a new spreadsheet.  Make sure 'balance', 'tuition', and 'paypal' columns are formatted as 'Financial'";
}

my %emails_seen = ();

# $y needs to start out as the index of the fist blank row, so we add one
# Perl arrays are zero-indexed, Google sheet rows are one-indexed, so we add another one
my @existing_rows = $invoice_sheet->rows();
my $y = @existing_rows + 1 + 1;

sub invoice_to_google {
    my $a = $_[0];

    # Balances will be negative, since these are people that owe
    # But we don't want to show people that on their invoice
    $a->{balance} =~ s/^-//;
    $a->{balance} = sprintf '%.2f', $a->{balance};
    $a->{tuition} = sprintf '%.2f', $a->{tuition};
    $a->{paypal} = paypal_amount $a->{balance};
    $a->{paypal_url} = paypal_url $a->{paypal};
    $a->{payment_word} = payment_word $a->{plan};
    ($a->{invoice_dt}, $a->{invoice_date}) = today();
    ($a->{payment_dt}, $a->{payment_date}) = payment_date();

    if (defined $a->{nobill}) {
        if ($a->{nobill} eq 'I' or $a->{nobill} eq 'B') {
            $a->{donotsend} = 1;
        }
    }

    my @parents = get_parents $a->{momefid};
    foreach my $parent (@parents) {
        if ($emails_seen{$parent->{email}}++) {
            next;
        }

        my $invid = record_to_db(%{$a}, %{$parent});

        if ($a->{donotsend} or $a->{balance} < $INV_THRESHOLD) {
            next;
        }

        my @row = ();

        # Parent info for invoice
        foreach my $f (qw/ firstname lastname email /){
            push @row, $parent->{$f};
        }

        # Blank columns to appease the mail merge app
        foreach my $n (1..3) {
            push @row, undef;
        }

        push @row, $invid;

        # Additional fields for invoice template
        foreach my $f (@inv_fields) {
            push @row, $a->{$f};
        }

        # I would use ->add_row(\%), but for some damned reason it can't handle
        # spaces in the "Column Names", the keys of the hash.
        # Spaces must be present in the @email_fields to keep the Google Sheet Mail Merge
        # application happy.
        my $x = 1;
        my @sheet_row = map { { row => $y, col => $x++, input_value => ce($_) } } @row;
        $invoice_sheet->batchupdate_cell( @sheet_row );

        $y++;
    }
}

sub ce {
    return '' unless defined $_[0];
    return $_[0];
}

sub get_account {
    my $momefid = $_[0];

    my $a = $dbh->selectrow_hashref(
        qq{ select momefid, tuition, plan, name, nobill from family where momefid = ?; },
        undef,
        $momefid,
    );

    ($a->{short_name}) = split '/', $a->{name};

    return $a;
}

sub get_balance {
    my $momefid = $_[0];

    my $count = $dbh->selectrow_hashref(
        qq{ select count(id) as count from ledger where type = 'debit' and momefid = ? },
        undef,
        $momefid,
    );

    unless ($count->{count}) {
        return 0, 0;
    }

    my $balance = $dbh->selectrow_hashref(
        qq{ select sum(amount) as balance from ledger where momefid = ?; },
        undef,
        $momefid,
    );

    return $balance->{balance}, $count->{count};
}

my @ids = $dbh->selectall_array(
    qq{ select momefid from family where session = (select id from session where active is not null); }
);

foreach my $id (@ids) {
    my $a = get_account($id->[0]);
    ($a->{balance}, $a->{count}) = get_balance($id->[0]);

    if ($a->{balance} < 0) {
        invoice_to_google($a);
    }
}
