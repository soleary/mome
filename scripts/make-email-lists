#!/usr/bin/env perl

use warnings;
use strict;

use Modern::Perl '2018';
use DBI;
use Excel::Writer::XLSX;
use POSIX 'strftime';

my @DOW = qw/ Sunday Monday Tuesday Wednesday Thursday Friday Saturday /;
my @GRADE = qw/ Zero First Second Third Fourth Fifth Sixth Seventh Eighth Ninth Tenth Eleventh Twelfth /;

my $OUTFILE = '2019-2020 Parent Email Lists.xlsx';
my $DBFILE = 'sjsmusic.db';
my $dbh = DBI->connect("dbi:SQLite:dbname=$DBFILE",'','', { RaiseError => 1 });

my $wb = Excel::Writer::XLSX->new($OUTFILE);
my $norm = $wb->add_format( font => 'Arial', size => 10 );
my $bold = $wb->add_format( font => 'Arial', size => 10, bold => 1 );
my $url = $wb->get_default_url_format();
my $ws = $wb->add_worksheet();

# enum       => query to get the list of things to group by. First elements are the group names,
#               second elements are bound to result query to produce list of desired email addresses.
# enum_type  => If 'dow' then day of week numbers will be translated to day names, 'grade' will translate
#               grade numbers to grade names.  Anything else is ignored.
# result     => query to be executed with each row from enum statement, to produce the deisred group
my %sths = (
    day  => {
        enum      => qq{ select distinct(day) from class_member order by day; },
        enum_type => 'dow',
        result    => qq{
        select p.firstname, p.lastname, p.email
            from person as p, family_member as fm, family as f
            where
                p.type = 'parent'
            and p.email is not null
            and p.id = fm.personid
            and fm.momefid = f.momefid
            and f.session = (select id from session where active is not null)
            and fm.momefid in
                (select momefid from family_member where personid in
                    (select personid from class_member where day = ? and inactive is null))
            order by lastname;},
    },
    class   => {
        enum      => qq{ select distinct(class) from class_member order by class; },
        enum_type => '',
        result    => qq{
        select firstname, lastname, email
            from person as p, family_member as fm, family as f
            where
                p.type = 'parent'
            and p.email is not null
            and p.id = fm.personid
            and fm.momefid = f.momefid
            and f.session = (select id from session where active is not null)
            and fm.momefid in
                (select momefid from family_member where personid in
                (select personid from class_member where class = ? and inactive is null))
            order by lastname;},
    },
    grade   => {
        enum      => qq{ select distinct(grade) from person where grade is not null order by grade; },
        enum_type => 'grade',
        result    => qq{
        select firstname, lastname, email
            from person as p, family_member as fm, family as f
            where
                p.type = 'parent'
            and p.email is not null
            and fm.momefid = f.momefid
            and p.id = fm.personid
            and f.session = (select id from session where active is not null)
            and fm.momefid in
                (select momefid from family_member where personid in
                    (select id from person as p where p.grade = ?))
            order by lastname;},
    },
    year    => {
        enum      => qq{ select id, name from session where active is not null; },
        enum_type => '',
        result    => qq{
        select p.firstname, p.lastname, p.email
            from person as p, family as f, family_member as fm
            where
                p.type = 'parent'
            and p.email is not null
            and fm.momefid = f.momefid
            and fm.personid = p.id
            and f.session = ?
            order by lastname;},
    },
);

my @rows = ();

push @rows, [ 'Parent Email Groups', '', strftime('Updated at %I:%M%P on %A, %B %e, %Y', localtime()) ], [ ];

foreach my $type (sort keys %sths) {
    my $enum_sth = $dbh->prepare($sths{$type}{enum});
    $enum_sth->execute();

    my @labels = ( 'By ' . ucfirst $type, 'To', 'Cc', 'Bcc' );

    my $result_sth = $dbh->prepare_cached($sths{$type}{result});

    push @rows, [ $labels[0] ];

    while (my $item = $enum_sth->fetch()) {
        $result_sth->execute($item->[0]);

        my @emails = ();
        while (my $row = $result_sth->fetch()) {
            push @emails, $row->[0] . ' ' . $row->[1] . ' <' . $row->[2] . '>';
        }

        my @row = ();

        foreach my $f (@labels) {
            if ($f =~ /^By/) {
                if ($sths{$type}{enum_type} eq 'dow') {
                    push @row, $DOW[$item->[0]];
                } elsif ($sths{$type}{enum_type} eq 'grade') {
                    push @row, $GRADE[$item->[0]];
                } else {
                    push @row, $item->[-1];
                }
            } else {
                push @row, hyperlink_emails($f, @emails);
            }
        }

        push @row, join ', ', @emails;
        push @rows, [ @row ];
    }
    push @rows, [ ];
}

my $x = 0;
foreach my $row (@rows) {
    my $y = 0;
    foreach my $cell ($row->@*) {
        my $fm = undef;
        if (($x == 0 and $y == 0) or $cell =~ /^By/) {
           $fm = $bold;
        } elsif ($cell =~ /^=HYPERLINK/) {
            $fm = $url;
        } else {
           $fm = $norm;
        }
        $ws->write($x, $y, $cell, $fm);
        $y++;
    }
    $x++;
}

sub ce {
    return '' unless defined $_[0];
    return $_[0];
}

sub hyperlink_emails {
    my $type = shift;
    my @emails = @_;

    my $link = qq{=HYPERLINK("mailto:?$type=} . join ', ', @emails;
    return $link . qq{", "Email as } . ucfirst $type . qq{")};
}
